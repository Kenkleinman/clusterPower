% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cps.ma.count.R
\name{cps.ma.count}
\alias{cps.ma.count}
\title{NOT READY, DO NOT RUN Power simulations for cluster-randomized trials: Multi-Arm Designs, Dichotomous Outcome.}
\usage{
cps.ma.count(nsim = 1000, nsubjects = NULL, narms = NULL,
  nclusters = NULL, probs = NULL, sigma_b_sq = NULL, alpha = 0.05,
  quiet = FALSE, ICC = NULL, method = "glmm",
  multi.p.method = "bonferroni", all.sim.data = FALSE, seed = 123,
  cores = 1, overall.power = FALSE, tdist = FALSE,
  poor.fit.override = FALSE)
}
\arguments{
\item{nsim}{Number of datasets to simulate; accepts integer (required).}

\item{nsubjects}{Number of subjects per treatment group; accepts a list with one entry per arm. 
Each entry is a vector containing the number of subjects per cluster (required).}

\item{probs}{Expected absolute treatment effect probabilities for each arm; accepts a scalar or a vector of length \code{narms} (required).}

\item{sigma_b_sq}{Between-cluster variance; accepts a vector of length \code{narms} (required).}

\item{alpha}{Significance level; default = 0.05.}

\item{quiet}{When set to FALSE, displays simulation progress and estimated completion time; default is FALSE.}

\item{method}{Analytical method, either Generalized Linear Mixed Effects Model (GLMM) or 
Generalized Estimating Equation (GEE). Accepts c('glmm', 'gee') (required); default = 'glmm'.}

\item{multi.p.method}{A string indicating the method to use for adjusting p-values for multiple
comparisons. Choose one of "holm", "hochberg", "hommel", "bonferroni", "BH", "BY",}

\item{all.sim.data}{Option to output list of all simulated datasets; default = FALSE.}

\item{seed}{Option to set.seed. Default is NULL.}

\item{cores}{String ("all") or scalar indicating the number of cores to be used for 
parallel computing. When this option is set to NULL, no parallel computing is used. Default = NULL.}

\item{overall.power}{Logical value indicating whether the user would like to return the overall p-value. 
The default is FALSE. This option uses \code{pbkrtest::PBmodcomp}, which can take a long time and 
provides an approximation based on parametric bootstrapping. There is no reliable alternative method for 
binomial outcomes, so proceed with caution if you choose to obtain estimates for overall power.}

\item{poor.fit.override}{Option to override \code{stop()} if more than 25\% of fits fail to converge or 
power<0.5 after 50 iterations; default = FALSE.}
}
\value{
A list with the following components:
\itemize{
  \item Data frame with columns "Power" (Estimated statistical power), 
               "lower.95.ci" (Lower 95% confidence interval bound), 
               "upper.95.ci" (Upper 95% confidence interval bound)
  \item Produced only when all.sim.data=TRUE, data frame with columns corresponding 
  to each arm with the suffixes as follows: 
                  ".Estimate" (Estimate of treatment effect for a given simulation), 
                  "Std.Err" (Standard error for treatment effect estimate), 
                  ".zval" (for GLMM) | ".wald" (for GEE), 
                  ".pval"
  \item Produced only when all.sim.data=TRUE, table of F-test (when method="glmm") or 
  chi^{2} (when method="gee") significance test results.
  \item Overall power of model compared to H0.
  \item List of \code{nsim} data frames, each containing: 
                  "y" (Simulated response value), 
                  "trt" (Indicator for treatment group), 
                  "clust" (Indicator for cluster)
  \item Character string containing the percent of
  \code{nsim} in which the glmm fit was singular, produced only when method == "glmm" & 
  all.sim.data==FALSE
  \item Vector containing of length \code{nsim} denoting whether 
  or not a simulation glmm fit was singular, produced only when method == "glmm" & 
  all.sim.data==TRUE
}
}
\description{
This set of functions utilize iterative simulations to determine 
approximate power for multi-arm cluster-randomized controlled trials. Users 
can modify a variety of parameters to suit the simulations to their
desired experimental situation.
}
\details{
Users must specify the desired number of simulations, number of subjects per 
cluster, number of clusters per treatment arm, group probabilities, two of the following: ICC, within-cluster variance, or 
between-cluster variance. Significance level, analytic method, progress updates, poor/singular fit override,
and simulated data set output may also be specified. This function validates the user's input 
and passes the necessary arguments to \code{cps.ma.count.internal}, which performs the simulations.

Because the models for count outcomes may be slower to fit than thise for other distributions, this function can run
across multiple cores using the \code{cores} argument. Supplying any value other than NULL to \code{cores} turns on
parallel computing using \code{foreach}. Users should expect that parallel 
computing may make model fitting faster than using a single core for more complicated models. For simpler models, 
users may prefer to use single thread computing (\code{cores}=1), as the processes involved in allocating memory and 
copying data across cores can sometimes increase computation time depending on the complexity of the simulation tasks.
}
\examples{
\dontrun{

nsubjects.example <- list(c(20,20,20,25), c(15, 20, 20, 21), c(17, 20, 21))
probs.example <- c(0.30, 0.21, 0.53)
sigma_b_sq.example <- c(25, 25, 120)

bin.ma.rct <- cps.ma.count(nsim = 10, nsubjects = nsubjects.example, 
                                     probs = probs.example,
                                     sigma_b_sq = sigma_b_sq.example, alpha = 0.05,
                                     quiet = FALSE, method = 'gee', 
                                     all.sim.data = FALSE, seed = 123)
}

}
\author{
Alexandria C. Sakrejda (\email{acbro0@umass.edu}, Alexander R. Bogdan, and Ken Kleinman (\email{ken.kleinman@gmail.com})
}
